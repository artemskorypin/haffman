#include <iostream> 
#include <fstream>
#include <vector>
#include <map>
#include <list>

using namespace std;

class Uzel
{
public:
	int key;//кол-во повторений
	char s;//символ
	Uzel *left, *right;//ссылки на левого и правого потомков
	Uzel() { left = NULL; right = NULL; }//констрктор по умолчанию
	Uzel(Uzel *l, Uzel *r)//конструктор с известными потомками
	{
		left = l;
		right = r;
		key = l->key + r->key;//при слиянии 2-ух символов, суммируется их кол-во повторений
	}

};

struct Sort//сравнивает 2 узла, если sort=1 то левый меньше правого и если 0, то наоборот
{
	bool operator() (const Uzel* l, const Uzel* r)
	{
		return l->key < r->key;
	}
};

vector<bool> code;//создаётся булев вектор для кодирования символа (для сжатия)
map<char, vector<bool> > buf;//создаём мап из символа и соответствующего ему в дальнейшем кода

void TreeHaf(Uzel *root)
{
	if (root->left != NULL)//проверяем наличие левого потомка
	{
		code.push_back(0);//когда идём влево добавляем в код символа 0
		TreeHaf(root->left); //рекурсивно идём дальше
	}
	if (root->right != NULL) //проверяем наличие правого потомка
	{
		code.push_back(1);//когда идём вправо добавляем в код символа 1
		TreeHaf(root->right);//рекурсивно идём дальше
	}
	if (root->right == NULL && root->left == NULL)//если у узла нет потомков->узел содержит символ
	{
		buf[root->s] = code;//в мап соответствующего символа передаём получившийся код
	}
	if (!code.empty())//если вектор кода не пуст
		code.pop_back();//удаляем последний элемент(чтобы исключить повторения кода с началом других кодов)
}

int main()
{
	ifstream f("code.txt", ios::in | ios::binary);//открываем файл для чтения, который нужно декодировать
	ofstream g("output.txt", ios::out | ios::binary);//открываем файл для записи декодированного текста
	//
	int x1, x2;
	char s;
	map<char, int> m;									//мапа для таблицы кодирования
	// считывание из файла code.txt и декодирование
	f.read((char*)&x1, sizeof(x1));								//считываем первое число для расшифровки таблциы												//отнимаем значение int
	while (x1>0) 
	{
		f.read((char*)&s, sizeof(s));											//считываем символ
		f.read((char*)&x2, sizeof(x2));											//считываем его значение
		x1-=40;																//отнимаем 8 бит символа и 32 его значения
		m[s]=x2;																//строим таблицу
	}
	list<Uzel*> L;//создаём список узлов
	map<char, int>::iterator ii;
	for (ii = m.begin(); ii != m.end(); ii++) 
	{
		Uzel* p = new Uzel;
		p->s = ii->first;//в узел записываем символ соответствующий символу из мапы
		p->key = ii->second;//аналогично в этот же узел записываем число повторений этого символа 
		L.push_back(p);//заносим узел в список узлов															//указатель скидываем в list
	}
	while (L.size() != 1) //пока не построим дерево с единственным корнем
	{
		L.sort(Sort());//сортируем список
		Uzel *Left = L.front(); //левый потомок-первый узел списка
		L.pop_front();//удаляем его из списка 
		Uzel *Right = L.front();//правый потомок-первый узел нынешнего списка 
		L.pop_front();//удаляем его из списка
		Uzel *pr = new Uzel(Left, Right);//создаём новый узел с соответствующими левым и правым потомками
		L.push_back(pr);//в конец списка добавляем получившийся узел (кол-во повторений=сумме повторений символов)
	}
	Uzel *root = L.front();//корнем является единственный оставшийся узел в списке 
	TreeHaf(root);
	char byte;//создаём переменную, в которую будем считывать символы из файла f
	int count = 0;//счётчик
	Uzel *p=root;
	byte = f.get();//считываем символ из файла f
	while (!f.eof())//пока файл не закончится
	{
		bool b = byte & (1 << (7 - count));//символ представляется как набор 0 и 1(в char их 8)
		if (b)//если 1 << (7 - count) цифра из 8 в нашем символе=1
			p = p->right;//узел переходит в правого потомка так, как это было при кодировании
		else//если 1 << (7 - count) цифра из 8 в нашем символе=0 
			p = p->left;//узел переходит в левого потомка так, как это было при кодировании
		if (p->left == NULL && p->right == NULL)//если мы дошли до листа дерева
		{
			g<<p->s;//записываем в файл символ хранящийся в данном листе дерева 
			p=root;//возвращяемся к корню дерева 
		}
		count++;//счётчик увеличивается
		if (count == 8)//как только счётчик равен 8, char символ заканчивается и нужен следующий символ из файла
		{ 
			count = 0;//обнуляем счётчик
			byte = f.get();//считываем из файла новый символ
		}
	}
    f.close();
    g.close();
	return 0;
}
