#include <iostream> 
#include <fstream>
#include <vector>
#include <map>
#include <list>

using namespace std;

class Uzel
{
public:
	int key;//кол-во повторений
	char s;//символ
	Uzel *left, *right;//ссылки на левого и правого потомков
	Uzel() { left = NULL; right = NULL; }//констрктор по умолчанию
	Uzel(Uzel *l, Uzel *r)//конструктор с известными потомками
	{
		left = l;
		right = r;
		key = l->key + r->key;//при слиянии 2-ух символов, суммируется их кол-во повторений
	}

};

vector<bool> code;//создаётся булев вектор для кодирования символа (для сжатия)
map<char, vector<bool> > buf;//создаём мап из символа и соответствующего ему в дальнейшем кода

void TreeHaf(Uzel *root)
{
	if (root->left != NULL)//проверяем наличие левого потомка
	{
		code.push_back(0);//когда идём влево добавляем в код символа 0
		TreeHaf(root->left); //рекурсивно идём дальше
	}
	if (root->right != NULL) //проверяем наличие правого потомка
	{
		code.push_back(1);//когда идём вправо добавляем в код символа 1
		TreeHaf(root->right);//рекурсивно идём дальше
	}
	if (root->right == NULL && root->left == NULL)//если у узла нет потомков->узел содержит символ
	{
		buf[root->s] = code;//в мап соответствующего символа передаём получившийся код
	}
	if (!code.empty())//если вектор кода не пуст
		code.pop_back();//удаляем последний элемент(чтобы исключить повторения кода с началом других кодов)
}

int main()
{
	ifstream f("text.txt", ios::out | ios::binary);//открываем файл для чтения, который нужно закодировать
	ofstream g("code.txt", ios::out | ios::binary);//открываем файл для записи закодированного текста
	map<char, int> m;//создаём, мап символ и соответствующее число повторений
	map<char, int> ::iterator ii;
	while (!f.eof()) //пока файл не закончился
	{
		char c = f.get();//считываем символ из файла в переменную с
		m[c]++;//число повторений этого символа увеличиваем
	}
	list<Uzel*> L;//создаём список узлов
	for (ii = m.begin(); ii != m.end(); ii++) //от начала мапы до конца
	{
		Uzel* p = new Uzel;//создаём узел
		p->s = ii->first;//в узел записываем символ соответствующий символу из мапы
		p->key = ii->second;//аналогично в этот же узел записываем число повторений этого символа 
		L.push_back(p);//заносим узел в список узлов
	}

	f.close();//закрываем файл с текстом
	g.close();//закрываем файл с бинарником
	return 0;
}
